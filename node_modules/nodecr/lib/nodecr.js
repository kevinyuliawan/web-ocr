// Generated by CoffeeScript 1.4.0
var Tesseract, exec, fs, tesseract, tmp;

exec = require('child_process').exec;

fs = require('fs');

tmp = require('tmp');

/*
Attention: Tesseract 3.01 or higher is needed for this to work
*/


Tesseract = (function() {
  var ConvertPreprocessor;

  function Tesseract() {}

  /*
  	@param image	Can be any format that your installed Leptonica library can process
  	(additional libraries might be required by Leptonica)
  	
  	@param callback	A function pointer
  	this function is called after the recognition has taken place
  	with a possible error as first and the resulting recognized text as second parameter
  	
  	@param languageCode	(Optional) a language code for the language to recognise
  	see http://code.google.com/p/tesseract-ocr/downloads/list for available languages (xxx.traineddata.gz)
  	any language you pass as an argument here must be unzipped into the tessdata directory beforehand
  	
  	@param pageSegMode	(Optional) The page segmentation mode.
  	As of March 4, 2012 tesseract supports the following options:
  	
  	0 = Orientation and script detection (OSD) only.
  	1 = Automatic page segmentation with OSD.
  	2 = Automatic page segmentation, but no OSD, or OCR
  	3 = Fully automatic page segmentation, but no OSD. (Default)
  	4 = Assume a single column of text of variable sizes.
  	5 = Assume a single uniform block of vertically aligned text.
  	6 = Assume a single uniform block of text.
  	7 = Treat the image as a single text line.
  	8 = Treat the image as a single word.
  	9 = Treat the image as a single word in a circle.
  	10 = Treat the image as a single character.
  	
  	See http://code.google.com/p/tesseract-ocr/source/browse/trunk/api/tesseractmain.cpp#95 for current state of options
  	
  	@param config	(Optional) A config file name
  */


  Tesseract.prototype.process = function(image, callback, languageCode, pageSegMode, config, preprocessor) {
    var _this = this;
    return (preprocessor || this.preprocessor)(image, function(err, processedImage, cleanup) {
      var f;
      if (err) {
        callback(err, null);
        return;
      }
      f = function(err, text) {
        if (cleanup != null) {
          _this.log("node-tesseract: Preprocessor cleanup");
          cleanup();
        }
        callback(err, text);
      };
      _this._runTesseract(processedImage, f, languageCode, pageSegMode, config);
    });
  };

  Tesseract.prototype._runTesseract = function(image, callback, languageCode, pageSegMode, config) {
    var _this = this;
    tmp.tmpName(function(err, output) {
      var command;
      if (err) {
        callback(err, null);
        return;
      }
      command = [_this.binary, image, output];
      if (languageCode) {
        command.push('-l');
        command.push(languageCode);
      }
      if (typeof pageSegMode !== 'undefined' && pageSegMode !== null) {
        command.push('-psm');
        command.push(pageSegMode);
      }
      if (config) {
        command.push(config);
      }
      command = command.join(' ');
      _this.log("node-tesseract: Running '" + command + "'");
      exec(command, function(err, stdout, stderr) {
        var outputFile;
        if (err) {
          callback(err, null);
          return;
        }
        outputFile = output + '.txt';
        fs.readFile(outputFile, function(err, data) {
          if (!err) {
            data = data.toString(_this.outputEncoding);
          }
          _this.log("node-tesseract: Deleting '" + outputFile + "'");
          fs.unlink(outputFile, function(err) {});
          callback(err, data);
        });
      });
    });
  };

  /*
  	A no-op preprocessor
  	
  	@param inputFile	The file to process
  	@param callback	 The callback to call when the processing is done (1st argument error, 2nd the outputfile (the processed input file))
  */


  Tesseract.prototype.preprocessor = function(inputFile, callback) {
    var cleanup, error, outputFile;
    error = null;
    outputFile = inputFile;
    cleanup = function() {};
    callback(error, outputFile, cleanup);
  };

  Tesseract.prototype.log = function() {
    console.log.apply(console, arguments);
  };

  Tesseract.prototype.binary = 'tesseract';

  Tesseract.prototype.outputEncoding = 'UTF-8';

  Tesseract.prototype.preprocessors = {
    convert: ConvertPreprocessor = function(inputFile, callback) {
      tesseract.log("node-tesseract: preprocessor: convert: Processing '" + inputFile + "'");
      tmp.tmpName({
        postfix: '.tif'
      }, function(err, outputFile) {
        var command;
        if (err) {
          callback(err, null);
          return;
        }
        command = ['convert', '-type', 'Grayscale', '-resize', '200%', '-sharpen', '10', inputFile, outputFile].join(' ');
        tesseract.log("node-tesseract: preprocessor: convert: Running '" + command + "'");
        exec(command, function(err, stdout, stderr) {
          var cleanup;
          if (err) {
            callback(err, null);
          } else {
            cleanup = function() {
              tesseract.log("node-tesseract: preprocessor: convert: Deleting '" + outputFile + "'");
              fs.unlink(outputFile, function(err) {});
            };
            callback(null, outputFile, cleanup);
          }
        });
      });
    }
  };

  return Tesseract;

})();

tesseract = new Tesseract;

module.exports = tesseract;
